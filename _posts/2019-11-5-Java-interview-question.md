---
layout: post
category: Java
title: 从Java的平台无关性引入的一系列面试题
tagline: by 炭烧生蚝
tags:
  - Java
---

> 在Java面试中，有一条很常见的询问路线：从对Java的认识，到谈Java的平台无关性，到Java中的反射机制，再到类加载机制，继而深入到双亲委派机制等。本文将根据这条路线，给出一份可供参考的回答，如有错误万望指正。（推荐读者们在回答的时候结合自己的认识和项目经历作答）

<!--more-->

## 1. 谈谈Java的Compile Once，Run Anywhere

### 一次编译到处运行是如何实现的？

Java程序从编写到运行需要经历这么个过程：首先编写java源代码，然后通过javac编译器将java源代码编译成.class字节码文件，然后把字节码文件交给虚拟机，虚拟机会在执行Java程序的时候把字节码转换为机器码执行。

字节码文件是平台无关性的重要一环。同一个Java程序能够在Linux，Windows等不同平台上运行，是因为不同平台上安装了不同的Java虚拟机，这些不同的虚拟机会根据同一份字节码文件，转换成各个平台对应的机器码，从而使Java程序在不同的平台上运行。

按照这个逻辑，只要是符合规范的字节码文件就能通过虚拟机在不同平台运行，我们完全可以使用另一种语言编写程序，编写完后把程序编译为字节码文件，然后通过虚拟机在不同的平台上运行。现实中也确实存在运行于Java虚拟机之上的其他语言程序。

### 为什么JVM不直接将源码解析成机器码执行？

> 不同的机器安装不同的虚拟机，JVM直接解析Java源码不是也能做到一次编译到处运行吗？

1. 这样每次执行之前就要进行各种检查（这是编译成字节码前的工作），降低了执行效率。
2. 上面提到的兼容其他语言的功能将无法实现。

## 2. JVM是如何加载.class文件的？

JVM是通过Class Loader类加载器来加载字节码文件的，在介绍如何加载之前要先讲讲它加载的目的地，也就是Java虚拟机。

### JVM的结构：

Java虚拟机是通过c/c++编写的，可以看作是一个模拟真实计算机的程序，通俗来说说它是一个跑在内存中的机器，而后面我们谈到的JVM的内存结构就是存放在我们真实计算机的内存中的。（后面我会直接讲JVM的内存）

JVM大致可以分为四个模块：
1. 类加载器：用于把字节码文件加载进运行时数据区
2. 运行时数据区：字节码文件的不同部分会被放入运行时数据区的不同地方
3. 执行器：执行字节码中的程序
4. 本地代码接口：调用宿主计算机的一些本地方法（c/c++或其他语言编写的接口）

其中运行时数据区是Java虚拟机的精华所在，它把字节码文件中的数据按一定的格式和数据结构组织存放好，方便了执行器调用。

### JVM是如何加载.class文件的

JVM是通过类加载器加载.class字节码文件的，而JVM中的类加载器不只一个，它是按照父子关系进行划分的，至于为什么要这么划分，这会涉及到双亲委派机制，这个稍后便讲。具体的父子关系如下：
1. BootStrapClassLoader：最顶层的类加载器，由C++编写，用于加载Java的核心类库
2. ExtClassLoader：Java编写，用于加载Java的扩展库
3. AppClassLoader：Java编写，用于加载应用程序所在目录下的class文件
4. 自定义ClassLoader：Java编写，用于定制化加载

由不同类加载器的作用可以知道，不同加载器加载的路径是不同的。但它们共同的任务都是把字节码文件加载到运行时数据区中（不同语言实现的类加载器具体加载部分的代码也会有所差别），更形象地说是把字节码文件中的二进制01数据加载到JVM中，并按照运行时数据区进行划分存放。

### 什么是双亲委派机制，为什么要制定双亲委派机制？

我们先从一个类的加载顺序开始讲起：
1. 当需要加载一个类时，如果没有自定义类加载器，默认会使用AppClassLoader进行加载，
2. AppClassLoader先会查找一下该类是否已经被加载，若已经被加载则返回，若没有则调用它的父加载器ExtClassLoader进行加载，
3. ExtClassLoader也会查找一下该类是否已经被加载，若已经被加载则返回，若没有则向上调用它的父加载器BootStrapClassLoader进行加载，
4. BootStrapClassLoader会尝试加载该类，若加载不到则返回
5. 接着ExtClassLoader也会尝试加载该类，若加载不到则返回
6. 接着AppClassLoader也会尝试加载该类，假设该类被加载到（在项目目录下），则成功返回，否则抛出ClassNotFoundException

当然以上过程也可以从自定义的类加载器开始，过程是一样的。这种先委派父加载器进行加载的机制就是双亲委派机制。

为什么不直接加载，而是往上委派双亲加载呢？

1. 因为内存资源是宝贵的，如果一个类已经加载过一次了，也就没有必要再加载一份相同的拷贝在内存中了。为了保证一个类只被加载一次，加载类时就会从最顶层的父类加载器开始加载，只要加载过了，在后续需要用的时候就会返回已经加载过的class文件。
2. 为了保证安全性和稳定性。Java自身是有许多核心类的，这些类都通过顶层的父加载器进行加载，保证运行的时候用的是Java系统自己的类。如果没有双亲委派机制保证，用户自己也可以编写一些系统类并用自己编写的类加载器进行加载，那么就会导致Java自身的系统类和用户编写的类混在一起，破坏了Java程序执行的安全性和稳定性。

### 额外：谈谈Java中的反射机制：

在问到类加载，JVM等话题时难免会问到反射机制，这里补充一下：

反射是Java中一个很强大的机制，要说清楚反射还得结合上面说到的JVM结构去谈。

由于类加载器会把整个.class文件加载进运行时数据区，.class文件中包含了一个类的字段，构造函数，以及各种方法，Java允许我们在程序中通过反射的方式直接操作这些数据。

```java
//比如我们可以根据类的限定类名获得一个类的实例对象
Class cc = Class.forName("xx.xx.Demo");
Demo demo = (Demo)cc.newIntance();

//获取并设置一个类的私有字段
Field name = cc.getDeclaredFied("name");
name.setAccessible(true);
name.set(demo, "Zhang san");

//或者调用一个类的方法（公有/私有）
Method sayHi = cc.getMethod("sayHi", String.class);
sayHi.invoke(demo, "Hello");
```

总结一句就是字节码中的类信息被加载进了运行时数据区，Java允许我们在程序中直接操作这些类信息。

为什么说Java的反射机制强大呢？这里就要说到Spring框架了。不知道Java的反射强大，总该知道Spring框架的强大了吧，Spring就是基于反射实现的。举个例子：Spring中最核心的概念莫过于控制反转了，通俗的解释就是把对象的生命周期交给框架管理，而不是由程序员管理。既然是交给框架管理对象，那创建对象就不能通过new关键字实现了，而是由框架通过反射创建，同理对象中方法的调用也由框架通过反射进行调用。